/*
 * Main documentation page for doxygen.
 */

/**
\mainpage
This is the developer documentation for the AYB base calling software. 
The function of the AYB program is described in detail in the AYB Function document. 

\section make Making the Program
Running the make utility from the 'src' directory will use the supplied Makefile to create an executable in the 'bin' directory; 
make test, make clean and make archive are also available. 
See \ref depends for required utilities and libraries.

\section run Running the Program
AYB runs from the command line with a number of optional arguments in standard long or short format.
Run the program with option --help or see the manual page for the current list.
Option argument input is handled in module ayb_options (ayb_options.c).
At least one non-option prefix argument is also required.

\section test Testing the Program
A module test script is available which runs each test executable with a fixed set of inputs and 
compares the output against a set of reference files.
See \ref modtest for further details.

A system test script is also available together with a suite of fixed inputs and reference files.
See \ref systest for further details.

\section doc Documentation
These AYB Developer pages are generated by running doxygen from the 'src' directory. 
This index file is created in ../../doc from the 'src' directory.
A User Manual page in html or man page format is generated by running asciidoc from the 'man' directory.
See the Makefile for the correct syntax.

\section inputs Inputs
Program inputs are:
- Intensities files in cif or txt format
- Optional initial Crosstalk (M), Noise (N), and Phasing (P) matrices in column per row format
- Optional quality calibration table

All file access for input is handled in module dirio (dirio.c).

\section outputs Outputs
Program outputs are:
- Base Call Sequence file in fasta or fastq format
- Quality calibration table
- Optional final working values
- Optional simulation data files

All file access for output is handled in module dirio (dirio.c).

\section mess Program Messages
All program messages, apart from a few at startup, are output using the General Messaging Utility in module message (message.c). 
Program messages are output to stderr which can be redirected either as a program option or in a run script. 
If program option is used then the full file path name must be supplied.

\section related Related Pages
On Related Pages see:
- \ref newmess
- \ref newopt
- \ref coding
- \ref depends
- \ref errors
- \ref values
- \ref modtest
- \ref switches
- \ref systest
- \ref version
*/

/**
\page newmess Adding a New Message
To add a new message:
- In message header, add new enum to #MSGTYPE; set suffix to indicate required parameters;
  keep enums with same suffix together and between the correct dummy E_END_s (enables testing)
- In message source, add format string to #MSG_TEXT, keeping the order exactly as in enum
 */

/** 
\page newopt Adding a New Program Option
To add a new program option:
- Create the option variable (usually where it is used), with initialisation, and a public method to set it
- Choose an option name and character
- Add to #Longopts structure indicating whether the option requires an argument
- Adjust any values in the option index enumeration (#OPTINDEX) if required 
- Add to short string in call to getopt_long in #read_options (with colon if argument required)
- Add to following switch statement to handle result
- Add to help, usage and manual text
 */
 
/**
\page coding Coding Standards
\section  codestyle General Style
The code is largeley written in C with an attempt to keep to the C99 standard;
use has been made of a few GNU constructs so the standard is in fact gnu99.
 
Some attempt has been made to use an Object style as far as C allows. 
A module is treated like a class in that:
- Module data is declared globally with access via module functions (to simulate members and methods)
- These module globals are declared static and are therefore private
- All local functions are also declared static
- There can be a startup routine named startup_<> (like a constructor, but can return a value)
- There can be a tidyup routine named tidyup_<> (like a destructor)
   
The above works well if the object is a known singleton, i.e. there is only a single instance. 
If more than one instance is required then a data structure must be declared 
and this structure object passed as a parameter in the methods. 
Ideally the contents of the structure are kept private with only a global pointer (typedef) for access 
so that all data manipulation is done within the module.

\section codenaming Naming Conventions

The following naming conventions are used:

\verbatim
Item                Case        Separator/Suffix        Notes

Typedef             UPPER       none or underscore 
(abstract data type)
Typedef             lower       none/end with _t        e.g. real_t
(user defined type) 
Struct              Mixed       none/end with 'T'       (also some older styles using _struct)
Enum Tag            Mixed       none/end with 'T'
Enum Val            UPPER       underscore              Use common prefix
Constants           UPPER       underscore	
Global Variables    Mixed       none or underscore      
Local Variables     lower       none                    Declare in inner most scope as close to code block as possible unless jumped by goto
Functions           lower       underscore              Start with a verb
\endverbatim

\section codeefficient Efficiency
The following conventions are used to improve the computational efficiency:

General:
- Use the const qualifier wherever possible

In a loop that is called many times:
- Construct loops so that array elements are accessed sequentially where possible
- Create a local copy of any global or structure variable
- Use integer type uint_fastn
- Precalculate as much as possible
- Try to avoid calls to other functions

\section codeother Other
- Although a single function return is sometimes considered good style, the general practice is to return early in case of error
- Use of goto is restricted to the need for cleanup in case of error; 
note some compilers issue a warning on a jump over variable initialisation 
- For public methods header comments need only be put in the source file as Doxygen will combine
 */
  
/**
\page depends Dependencies
The following utilities and libraries are required to make/run the program:

Utilities:
- gcc (GNU C compiler; part of GNU Compiler Collection)
- gfortran (GNU Fortran compiler; part of GNU Compiler Collection)
- make (GNU make utility)

Libraries:
- BLAS (Basic Linear Algebra Subprograms)
- LAPACK (Linear Algebra PACKage)
- zlib (general purpose compression library)
- bzip2 (alternative compression library)

Documenting:
- AsciiDoc (Text based document generation)
- doxygen (Generate documentation from source code)

External Links:
- <a href="http://gcc.gnu.org/">GCC</a>
- <a href="http://www.gnu.org/software/make/">GNU Make</a>
- <a href="http://www.netlib.org/blas/">BLAS</a>
- <a href="http://www.netlib.org/lapack/">LAPACK</a>
- <a href="http://zlib.net/">zlib</a>
- <a href="http://bzip.org/">bzip2</a>
- <a href="http://www.methods.co.nz/asciidoc/">AsciiDoc</a>
- <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>
*/

/**
\page errors Error Handling
There is no program wide error handler. 
Each function detects potential errors and returns an error indication which may be a null pointer. 
Any allocated memory should be freed before an error return.

The following error checking should be routinely carried out:
- Check file handles are not null before use
- Check pointers are not null before use
- Check return from memory allocation is not null

Any allocated memory must be freed when finished with, not forgetting any allocated by a function call. 
It may be useful to set the pointer to null when memory is freed and many standard free routines return null for this purpose. 
*/

/**
\page values Expected Values
The AYB program assumes the following input value ranges:
- The number of Clusters is typically hundreds of thousands
- The Lane and Tile Indexes and Cluster Coordinates are integral
- All other input values are real with an expected range of +/- 10,000 and an accuracy of 1dp
 */

/**
\page modtest Module Testing
Before testing, ensure sources are up to date.
Build a set of test executables with 'make test'.

Executables are currently available for:
- cluster
- matrix
- message
- mpn
- nuc
- tile
- xio

The script AYB_module_test.sh runs each test executable with a fixed set of inputs and 
compares the output against a set of reference files. 
A report is sent to standard output.

e.g ./AYB_module_test.sh > test-results.txt

File locations in the script assume it is run from the AYB top directory.
Expected inputs are located in sub-directory test.
Output files are created in sub-directory log and compared with reference files in sub-directory logref.

Module functions are tested as fully as possible including null and invalid function parameters. 

Note: output from module message (message.c) and associated program messages will be different from the reference 
because of the randomised filename function and timestamp. 
Check that is the only difference and that each generated filename is unique.

The module testing can be expanded, and the reference files updated if required, as functionality changes.
*/

/**
\page switches Program Switches
 The following program switches are available:
 - NDEBUG - exclude debug code (set by default)
 - NFORTRAN - exclude links to fortran that requires compilation (libraries are not affected)
 - USEFLOAT - use float for calculations instead of double
 */

/**
\page systest System Testing
The System Test structure is located in the AYB SystemTest directory.

The system test script AYB_system_test.sh runs AYB with fixed inputs and 
compares the output against a set of reference files.
The test report is sent to standard output which can be redirected as required:

e.g ./AYB_system_test.sh > test-sys.txt

It is recommended that the tests are run on the EBI farm to ensure adequate resources.

File locations in the script assume it is run from the SystemTest top directory.
The expected inputs are located in the test sub-directory.
The AYB executable to be tested must be located in the bin sub-directory. 
It is possible to supply an alternative executable file name as a script parameter but this will lead to 
additional differences in message log and simulation data file output.

All normal run modes are tested but failure mode testing is done at the module level. 
The selection of program options is tested in principle rather than exhaustively. 

The tests are grouped with various non-overlapping aspects of functionality combined.
Test groups have an associated 3 letter suffix as follows:
- blk: Cif input, multiple blocks
- cif: Cif input, default block, all output
- fol: Cif run-folder input
- gcs: Cif input, composition, mu and solver in
- mat: Cif input, blockstring=cycles, predetermined matrices and qualtab input
- mul: Cif input, niter in, fasta output, multiple prefix, prefix as prefix, partial path, stderr redirect
- txt: Txt input, default block, all output, debug logging
- zip: Zip txt input, blockstring=cycles

Each group has its own reference and output sub-directories (indicated by the suffix in the name) located under SystemTest.
Output directories are created if they do not exist otherwise any existing contents are deleted.

When the script has finished check any error messages and the test report. 
All outputs should match the reference with the exception of:
- Message log files contain a timestamp.
- Output simulation data contains an AYB version and sometimes a timestamp.
- Where message log is to a redirect of stderr the quality calibration file output will be to a randomised file name.

The system testing can be expanded, and the reference files updated if required, as functionality changes.
*/

/**
\page version Version Control
 The program version and release date are stored in ayb_version.c and should be updated before each formal release. 
 The version date is stored as an integer representing yyyymmdd.
 */
